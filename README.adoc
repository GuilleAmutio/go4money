= go4money

go4money is a project to understand core and advanced concepts of the Go programming language.

== Migrations

The database used is PostgreSQL. The schema will be generated using https://dbdiagram.io[dbdiagram.io].

To generate the migrations we will use https://github.com/golang-migrate/migrate[Go Migrate].

The ORM used will be SQLC, however GORM and SQLX is a great alternative

== Create CRUD using SQLC

The GitHub repository of SQLC can be found https://github.com/kyleconroy/sqlc[here].

* Execute `sqlc init`, it will generate a YAML file
* Configure the settings of the YAML. See the Getting started chapter at the GitHub docs
* Create query and sqlc folders
* Define the queries inside the query folder
* Run `sqlc generate`
* This command will generate:
** `models.go` file, with the tables definition
** `db.go` file, dbtx interface
** `<tableName>.sql.go`, queries translated to Go language

## Database unit tests

In Go, test are defined by adding `_test` at the end of the name of the file. The `main_test.go` is where the connection to the database is defined. Also, the line `os.Exit(m.Run())` instructs the program that, once the tests are run, it should exit.

Each table will have its own series of queries that will make use of the `testify` package. This library allows the use of the `require` function.

Test have to be created for query.

## Transactions

A transaction is a simple unit of work that is made up of multiple database operations

Transaction lifecycle:

* Start transaction with BEGIN command
* Once actions are performed make it permanent using the COMMIT command
* If any of the queries fail, use ROLLBACK command

Transactions follow the ACID principle:

* Atomicity: All changes to the data must be performed or none
* Consistency: Only valid data is saved
* Isolation: Transactions do not affect each other
* Durability: Written data will not be lost

### Create a transaction

Define the Store struct, this store will provide all functions to execute the DB queries. These queries are generated by SQLC in the previous section.

```
type Store struct {
	*Queries
	db *sql.DB
}
```

Define a general function that will perform the transaction itself. This function will execute the transaction and check the result. If any error happens it will perform a rollback. If every action is executed succesfully it will execute the commit command to make them permanent.

```
func (store *Store) execTx(ctx context.Context, fn func(*Queries) error) error {
	tx, err := store.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	q := New(tx)
	err = fn(q)
	if err != nil {
		if rbErr := tx.Rollback(); rbErr != nil {
			return fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
		}
		return err
	}

	return tx.Commit()
}
```

Define a function for each transaction that can be executed and the actions to perform in the database.

== Database Deadlock

=== Isolation levels

From low to high:
* Read uncommitted: Can see data written by uncommitted transaction
* Read committed: Only see data written by committed transaction
* Repeteable read: Same read query always returns same result
* Serializable: Can achieve same result if execute transactions serially in some order instead of concurrently

=== Read Phenomena

* Dirty read: A transaction read data written by other concurrent uncommitted transaction
* Non-repeteable read: A transaction reads the same row twice and sees different value because been it has been modified by other committed transaction
* Phantom read: A transaction re-executes a query to find rows that satisfy a condition and sees a different set of rows, due to changes by other committed transaction
* Serialization anomaly: The result of a group of concurrent committed transactions is impossible to achieve if we try to run them sequentially in any order without overlapping.