## Transactions

A transaction is a simple unit of work that is made up of multiple database operations

Transaction lifecycle:

* Start transaction with BEGIN command
* Once actions are performed make it permanent using the COMMIT command
* If any of the queries fail, use ROLLBACK command

Transactions follow the ACID principle:

* Atomicity: All changes to the data must be performed or none
* Consistency: Only valid data is saved
* Isolation: Transactions do not affect each other
* Durability: Written data will not be lost

### Create a transaction

Define the Store struct, this store will provide all functions to execute the DB queries. These queries are generated by SQLC in the previous section.

```
type Store struct {
	*Queries
	db *sql.DB
}
```

Define a general function that will perform the transaction itself. This function will execute the transaction and check the result. If any error happens it will perform a rollback. If every action is executed succesfully it will execute the commit command to make them permanent.

```
func (store *Store) execTx(ctx context.Context, fn func(*Queries) error) error {
	tx, err := store.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	q := New(tx)
	err = fn(q)
	if err != nil {
		if rbErr := tx.Rollback(); rbErr != nil {
			return fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
		}
		return err
	}

	return tx.Commit()
}
```

Define a function for each transaction that can be executed and the actions to perform in the database.

### Database Deadlock

### Isolation levels

From low to high:
* Read uncommitted: Can see data written by uncommitted transaction
* Read committed: Only see data written by committed transaction
* Repeteable read: Same read query always returns same result
* Serializable: Can achieve same result if execute transactions serially in some order instead of concurrently

### Read Phenomena

* Dirty read: A transaction read data written by other concurrent uncommitted transaction
* Non-repeteable read: A transaction reads the same row twice and sees different value because been it has been modified by other committed transaction
* Phantom read: A transaction re-executes a query to find rows that satisfy a condition and sees a different set of rows, due to changes by other committed transaction
* Serialization anomaly: The result of a group of concurrent committed transactions is impossible to achieve if we try to run them sequentially in any order without overlapping.