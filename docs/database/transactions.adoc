## Transactions

A transaction is a simple unit of work that is made up of multiple database operations

Transaction lifecycle:

* Start transaction with BEGIN command
* Once actions are performed make it permanent using the COMMIT command
* If any of the queries fail, use ROLLBACK command

Transactions follow the ACID principle:

* Atomicity: All changes to the data must be performed or none
* Consistency: Only valid data is saved
* Isolation: Transactions do not affect each other
* Durability: Written data will not be lost

### Create a transaction

Define the Store struct, this store will provide all functions to execute the DB queries. These queries are generated by SQLC in the previous section.

```
type Store struct {
	*Queries
	db *sql.DB
}
```

Define a general function that will perform the transaction itself. This function will execute the transaction and check the result. If any error happens it will perform a rollback. If every action is executed succesfully it will execute the commit command to make them permanent.

```
func (store *Store) execTx(ctx context.Context, fn func(*Queries) error) error {
	tx, err := store.db.BeginTx(ctx, nil)
	if err != nil {
		return err
	}

	q := New(tx)
	err = fn(q)
	if err != nil {
		if rbErr := tx.Rollback(); rbErr != nil {
			return fmt.Errorf("tx err: %v, rb err: %v", err, rbErr)
		}
		return err
	}

	return tx.Commit()
}
```

Define a function for each transaction that can be executed and the actions to perform in the database.

### Database deadlock && Test-driven-development